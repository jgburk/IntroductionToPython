# -*- coding: utf-8 -*-
"""IntroToPython_Concepts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b5o2NFIt8buPxflpT7J6rfMszInkvRmk

# Getting Started

Let's check our Python version
"""

!python --version

"""# Strings

We can print a simple string
"""

print('hello world')

"""Comments use #"""

# comment 1
print('not a comment') # comment 2
# comment 3

"""Even when we don't print, we can see a returned value."""

'hello world' # Google colab uses "IPython" AKA "Jypyter" notebooks which print return values from separate "blocks" AKA "cells".
# The "blocks" terminology should be avoided in serious technical discussions so as not to conflate these notebook sections with
# computer programming blocks https://en.wikipedia.org/wiki/Block_(programming).

"""Only the last returned value.."""

'hello'
'world'

"""We can check variable types with the type() function."""

a = 'b'
print(a) # we can evaluate and print variables with print()
type(a)

a = "b" # double quotes also work
print(a)
type(a)

"""Docstrings"""

a = """b""" # triple quotes also work
print(a)
type(a)

a = """b
is now a
multi-line
string."""
print(a)
type(a)

a = """b \
is now a \
single-line \
string."""
print(a)
type(a)

"""Single quotes can't be used for multi-line strings"""

a = "b
ut this is
not valid syntax"

a = "b\
ut this is \
ok"
print(a)
type(a)

"""E is not a defined variable"""

type(E)

"""# Numerics"""

a = 0.1
b = 0.5
print(a)
print(b)
print(a == b)

print(a is b) # tests whether a and b are the same object

c = 0.1
print(a)
print(c)
print(a is c)
print(a == c)

c = a
print(a is c)

print(a)
print(b)

print(type(a))
print(type(b))
print(type(a) is type(b))

a = 1
type(a)

a = 1.01
type(a)

a = b'\x00\x10'
type(a)

print(f'a == 16? {a == 16}')
print(f'a = {a}')
print(f'len(a) = {len(a)}')
print(f'a[0] = {a[0]} = {bin(a[0])}')
print(f'a[1] = {a[1]} = {bin(a[1])}')

"""Endianness"""

# endianness is the byte order (big or little)
c = int.from_bytes(a,"big")     # big-endian means most significant byte is at lowest index
print(f'c == 16? {c == 16}')
d = int.from_bytes(a,"little")  # little-endian means most significant byte is at the highest index
print(f'd == {d}')

a = 100
print(f'1. a is equal to {a}')                        # the f-strings mechanism is how we're going to interpolate strings here
print("2. a is equal to",a)                           # space character is the default separator
print("3. a is equal to ",a,sep="")                   # we can set the separator with sep=
print("4. a is equal to {a_value}".format(a_value=a)) # we can name parameters and use .format()
print("5. a is equal to %s" % a)                      # the old way

"""Numeric operations"""

print(2 + 3)  # addition
print(2 * 3)  # multiplication
print(2 - 3)  # subtraction
print(2 / 3)  # division (INTEGER DIVISON IN PYTHON 2)
print(2 // 3) # integer division
print(2 ** 3) # power
print(2 % 3)  # modulus

"""Python doesn't have the technology to divide by zero"""

z = 1/0

z = 12
print(z)
z += 5
print(z)
z /= 5
print(z)
z **= 2
print(z)

"""Sometimes we have to use both single and double quotes"""

z = float('inf')
z /= 2
print(z)
z /= z
print(z)
print(f'is z nan? {z != z}')

print(f"is nan equal to nan? {float('nan') == float('nan')}") #note single and double quotes are required here

"""int() is used to create int from other types... similar functions exist for other types"""

z = float(5.5)
type(z)

b = int(z)
type(b)

print(int(5.5))

print(int(5.9))

print(int(6.0000000000001))

print(int(-5.5)) # rounding toward 0

"""# Booleans"""

tx = True
fx = False
type(tx)

print(tx^fx) # bitwise XOR

print(tx != fx) # logical XOR

print(0^0)
print(0^1)
print(1^0)
print(1^1)

print(0 != 0)
print(0 != 1)
print(1 != 0)
print(1 != 1)

print(tx or fx)

print(0 or 0)
print(0 or 1)
print(1 or 0)
print(1 or 1)

print(tx and fx)

print(0 and 0)
print(0 and 1)
print(1 and 0)
print(1 and 1)

print(not tx)
print(not fx)

print(not 1)
print(not 0)

"""# Lists"""

z = [1,2]
type(z)

len(z)

print(z)
print(bool(z))

z[0:2]

z[0:1]

z[1:2]

print(f'z[0] == {z[0]}')
print(f'z[1] == {z[1]}')

"""index -0 is the same as 0"""

print(f'z[-0] == {z[-0]}')

print(f'z[-1] == {z[-1]}') # same as z[1]
print(f'z[-2] == {z[-2]}') # same as z[0]

"""z doesn't have an index after 1"""

print(f'z[2] == {z[2]}')

"""z also doesn't have an index before 0"""

print(f'z[-3] == {z[-3]}')

x = [1,2,3,4,5,6,7,8,9,10]
print(f'x[0:5:2] is {x[0:5:2]}')
print(f'x[0:10:3] is {x[0:10:3]}')

z = [1,2]
x = [1,2]
print(f'z == x? {z == x}')
x[0] = 100
print(f'z == x? {z == x}')
print(f'x == {x}')

"""# Tuples"""

z = (1,2)
type(z)

z = (1)
type(z)

z = (1,)
type(z)

x = (1,2)
print(f'z == x? {z == x}')

z = (1,2,2,2)
print(z)

x[0] = 100

"""# Dictionaries"""

A = dict(key1=1, key2=2)
A["key3"] = 300
Y = A["key2"] # double quotes
Z = A["key3"]
print(Y)
print(Z)

example_dictionary = {'key1':'value1', 'key2':'value2', 1000:'value_9000'} # curly braces may be used instead of dict()
print(example_dictionary['key1']) # single quotes
print(example_dictionary[1000])

example_dictionary['key3'] = 7
example_dictionary['12345'] = 'seven'
print(example_dictionary['key3'])
print(example_dictionary['12345'])

print(example_dictionary['key4'])

"""# Sets"""

a = set([1,2,2,2])
b = set([1,2])
a == b

example_set = {'value1', 'value2',4,5.5}
print(3 in example_set)
example_set.add(3)
print(3 in example_set)
print(5.5 in example_set)

example_set.add('value1') # idempotency
example_set.add(3)
example_set.add(3)
example_set.add(3)

print(example_set)

example_set.remove(3)
print(example_set)

"""# Loops"""

z = 5
while z < 10: # loop invariant
  print(z)
  z = z + 1

z = range(0)
print(f'type(z) == {type(z)}')
print(f'range(5) == {range(5)}')

for i in range(3):
  print(i)

for i in range(10):
  if i % 2 == 0:
    print(i)

for i in range(10):
  if i % 2 == 0:
    print(i)
  elif i % 3 == 0:
    print(i * 2)
  else:
    print("--")

"""Comprehensions"""

# list "comprehension" is an example of "pythonic" thinking
[print(i) for i in range(10) if i % 2 == 0]

# the list of "None" is returned above because print() prints but does not return a value
print([i for i in range(10) if i % 2 == 0])

# chain elses in a comprehension for conditional logic
print([i if i % 2 == 0 else i * 2 if i % 3 == 0 else "--" for i in range(10)])

"""Control Flow"""

for x in range(10):
    if x == 8:
        print("8!")
        continue
    print("not 8!")

"""# Functions"""

# a function with a return value and zero parameters
def function1():
  return 1

z = function1()

print(f'function1 returned {z}')

#Some languages might refer to code like this as a "procedure" because it does not appear to return a value.
#In python, this returns None and is correctly referred to as a "function".
def function2():
  print("hello2")

x = 100

print(f'x is set to {x}')

x = function2()

print(f'function2 returned {x}')

# function with a parameter
def function3(parameterA):
  z_string = f'ZZZ - {parameterA} - ZZZ'
  return z_string

argumentA = "im sleep" # the argument is "im sleep"

output = function3(argumentA) # we would say the argument is "passed" to the function

print(output)

def square_if_odd(n):
    if n % 2 != 0:
        return n * n
    return n

print(square_if_odd(2))
print(square_if_odd(3))
print(square_if_odd(4))
print(square_if_odd(5))

def add_three_numbers(a,b,c):
  return a + b + c

add_three_numbers(1,2,10)

def add_two_or_three_numbers(a,b,c=0): #functions allow positional and optional keyword arguments
  return a + b + c

print(add_two_or_three_numbers(5,20, 1))
print(add_two_or_three_numbers(5,20))

"""An error occurs if functions are called without valid arguments"""

print(add_two_or_three_numbers(5))

def mult_and_sub(a,b):
  return a * b - a - b

p = [1]
q = [3]
z = map(mult_and_sub,p,q)

print(f'first call returns {list(z)}')

p = [1,2,-1]
q = [3,4,10]
z = map(mult_and_sub,p,q)

print(f'second call returns {list(z)}')

"""# The random module"""

import random

def randomly_select_number(a,b,c):
  return random.choice([a,b,c])

randomly_select_number(1,2,10)

help(random)

from random import randint as ri
a = 1
b = 100
print(f'a random number from {a} to {b}: {ri(a,b)}')

random.random()

random.seed(123)
print(random.random())
print(random.random())
print(random.random())

import random as rnd
print(f'first call returns {rnd.random()}')

import random as abcdef123
print(f'second call returns {abcdef123.random()}')

print(f'third call returns {random.random()}')

"""# The re module"""

import re
txt = "this is an example of a multi-character string with several words for \
the regular expression package demonstration in a simple introduction to python\
 tutorial without paying attention to grammar"
pattrn = re.compile("[\s+]([a-zA-Z]+ing)[\s+]([a-zA-Z]+)",flags=0)
for match in pattrn.finditer(txt):
  print(match.groups())
  print(match.group(1))

help(re)

"""# File I/O"""

file_name = "text_file.txt"
file_pointer = open(file_name,'w')
print(f"is it closed? {file_pointer.closed}")
file_pointer.close()
print(f"is it closed? {file_pointer.closed}")

new_file = open('example.txt','w')
new_file.write("this is sample text!")
new_file.close()

existing_file = open('example.txt','r') 
x = existing_file.readline()
existing_file.close()

print(f'x is now set to {x}')

print(new_file.closed)
print(existing_file.closed)

file_pointer = open(file_name,'w')
try:
    file_pointer.write("aaaaaaaaa\nbbbbbbbbbb\nccccccccccc\n")
finally:
    file_pointer.close()

file_pointer = open(file_name,'r')
try:
  print(f'first line = {file_pointer.readline()}')
finally:
  file_pointer.close()

import sys # catch and print file I/O exceptions

file_pointer = open(file_name,'r')
try:
  print(f'file text = {file_pointer.readlines()}')
  file_pointer.write("zzzzzzzz!!!!!!")
except:
  print(f"an exception occurred: {sys.exc_info()[0]}...")
finally:
  file_pointer.close()
  print(f'closed the {file_name} file pointer')

# with encapsulates the open() function and 
# can be used instead of the try/finally syntax above
with open(file_name, 'r') as file_pointer2:
  print(file_pointer2.readline())
  print(file_pointer2.readline())

print(f"closed? {file_pointer2.closed}")

"""with will show exceptions"""

with open(file_name, 'r') as file_pointer3:
  print(file_pointer3.readline())
  print(file_pointer3.readline())
  file_pointer3.write("zzzzzz")

"""and with will still close file pointers"""

print(f"closed? {file_pointer3.closed}")

"""# The NumPy module"""

import numpy as np # using "np" for the numpy package is a common convention

array1 = np.array([0,1,2])
type(array1)

"""there's plenty of online documentation at https://numpy.org/"""

help(np)

array2 = np.array([[10,20,30],[40,50,60]])
type(array2)

print(array1.shape)
print(array2.shape)

print(array1[0:2])
print(array1[0:3])

"""We can do this"""

print(array1[0:100])

"""We can't actually access those indices"""

print(array1[100])

print(array2)

print(array2[1,1:3])

array3 = np.transpose(array2)

print(array3)

print(array3.shape)